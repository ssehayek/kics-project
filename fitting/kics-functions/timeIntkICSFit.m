% kICSNormTauFitFluctNoiseBleach(...) help header

function out = timeIntkICSFit(params,kSq,tauVector,k_p,T,varargin)

errBool = 0;

for i = 1:length(varargin)
    if any(strcmpi(varargin{i},{'error','err','residual','res'})) % output error (input calculated ACF)
        errBool = 1;
        ydata = varargin{i+1};
    end
end

s = struct('diffusion',params(1),'r',params(2),'K',params(3),'frac',params(4),'w0',params(5),'sigma',params(6));

[tauGrid,kSqGrid] = meshgrid(tauVector,kSq);

% diffusing autocorrelation factor
diff_term = (-1).*(s.diffusion.*kSqGrid).^(-1).*exp(1).^((-1).*(s.diffusion.*kSqGrid).*(1+tauGrid)+(-1).*s.K.*(1+tauGrid)+(-1).*k_p.*( ...
  T+tauGrid)).*((-1)+exp(1).^k_p).^(-1).*((-1).*exp(1).^(k_p.*T)+exp(1).^( ...
  k_p.*tauGrid)).*((s.diffusion.*kSqGrid)+s.K).^(-1).*((s.diffusion.*kSqGrid)+k_p).^(-1).*((s.diffusion.*kSqGrid)+s.K+k_p).^(-1).*((-1).*(s.diffusion.*kSqGrid).*(( ...
  -1)+exp(1).^((s.diffusion.*kSqGrid)+s.K)).*((-1)+exp(1).^((s.diffusion.*kSqGrid)+s.K+k_p)).*((s.diffusion.*kSqGrid)+k_p).*((-1)+s.r)+exp( ...
  1).^(s.K+s.K.*tauGrid).*((-1)+exp(1).^(s.diffusion.*kSqGrid)).*((-1)+exp(1).^((s.diffusion.*kSqGrid)+k_p)).*((s.diffusion.*kSqGrid)+s.K).*((s.diffusion.*kSqGrid)+ ...
  s.K+k_p).*s.r).*(T+(-1).*tauGrid).^(-1);
%
% static autocorrelation term
static_term = (1/2).*exp(1).^((-1).*s.K.*(1+tauGrid)+(-1).*k_p.*(2.*T+tauGrid)).*((-1).*exp(1) ...
  .^(k_p.*T)+exp(1).^(k_p.*tauGrid)).*s.K.^(-1).*k_p.^(-2).*(s.K+k_p).^(-1).*(exp( ...
  1).^(k_p.*T).*k_p.^2.*((-1)+s.r)+(-1).*exp(1).^(s.K+k_p.*T).*k_p.^2.*((-1) ...
  +s.r)+exp(1).^(k_p+k_p.*T).*k_p.^2.*((-1)+s.r)+(-2).*exp(1).^(s.K+k_p+k_p.*T) ...
  .*k_p.^2.*((-1)+s.r)+exp(1).^(2.*s.K+k_p+k_p.*T).*k_p.^2.*((-1)+s.r)+(-1).* ...
  exp(1).^(s.K+k_p.*(2+T)).*k_p.^2.*((-1)+s.r)+exp(1).^(2.*s.K+k_p.*(2+T)).* ...
  k_p.^2.*((-1)+s.r)+(-2).*exp(1).^((s.K+k_p).*(1+tauGrid)).*s.K.*(s.K+k_p).*s.r+(-2).* ...
  exp(1).^(s.K+k_p+k_p.*T+s.K.*tauGrid).*s.K.*(s.K+k_p).*s.r+exp(1).^(s.K+(s.K+k_p).*tauGrid).*s.K.* ...
  (s.K+k_p).*s.r+exp(1).^(s.K+2.*k_p+(s.K+k_p).*tauGrid).*s.K.*(s.K+k_p).*s.r+(-1).*exp(1) ...
  .^(s.K+2.*k_p+k_p.*T+s.K.*tauGrid).*s.K.*((-1)+k_p).*(s.K+k_p).*s.r+exp(1).^(s.K+k_p.*T+ ...
  s.K.*tauGrid).*s.K.*(1+k_p).*(s.K+k_p).*s.r).*(T+(-1).*tauGrid).^(-1).*((-1)+coth(k_p));
%
% diffusing autocorrelation term (norm)
diff_term_norm = 2.*(s.diffusion.*kSqGrid).^(-1).*exp(1).^((-1).*(s.diffusion.*kSqGrid)+(-1).*s.K+(-1).*k_p.*T).*((-1)+exp(1) ...
  .^k_p).^(-1).*((-1)+exp(1).^(k_p.*T)).*((s.diffusion.*kSqGrid)+s.K).^(-1).*k_p.^(-1).*((s.diffusion.*kSqGrid)+k_p) ...
  .^(-1).*((s.diffusion.*kSqGrid)+s.K+k_p).^(-1).*((s.diffusion.*kSqGrid).^3.*exp(1).^((s.diffusion.*kSqGrid)+s.K).*((-1)+exp(1).^k_p)+( ...
  -1).*exp(1).^s.K.*((-1)+exp(1).^(s.diffusion.*kSqGrid)).*s.K.*k_p.*(s.K+k_p).*s.r+(s.diffusion.*kSqGrid).^2.*(k_p+(-1) ...
  .*k_p.*s.r+exp(1).^s.K.*k_p.*s.r+exp(1).^((s.diffusion.*kSqGrid)+s.K+k_p).*(s.K+k_p+s.K.*s.r)+(-1).*exp( ...
  1).^((s.diffusion.*kSqGrid)+s.K).*(s.K+2.*k_p+s.K.*s.r))+(s.diffusion.*kSqGrid).*((-1).*k_p.^2.*((-1)+s.r)+exp(1).^s.K.* ...
  k_p.*(2.*s.K+k_p).*s.r+exp(1).^((s.diffusion.*kSqGrid)+s.K+k_p).*s.K.*(k_p+s.K.*s.r)+(-1).*exp(1).^((s.diffusion.*kSqGrid)+ ...
  s.K).*(k_p.*(s.K+k_p)+s.K.*(s.K+2.*k_p).*s.r))).*T.^(-1);
%
% static autocorrelation term (norm)
static_term_norm = (-1/2).*exp(1).^((-1).*s.K+(-2).*k_p.*T).*((-1)+exp(1).^(k_p.*T)).* ...
  s.K.^(-1).*k_p.^(-2).*(s.K+k_p).^(-1).*(exp(1).^s.K.*((-1)+exp(1).^k_p) ...
  .^2.*s.K.*(s.K+k_p).*s.r+exp(1).^(k_p.*T).*(2.*(1+exp(1).^k_p).*k_p.^2.*(( ...
  -1)+s.r)+exp(1).^s.K.*(exp(1).^(2.*k_p).*s.K.*(k_p.*((-2)+s.r)+(-1).*s.K.*s.r)+( ...
  s.K+k_p).*(3.*s.K.*s.r+2.*k_p.*(1+((-1)+s.K).*s.r))+2.*exp(1).^k_p.*((-1).* ...
  s.K.^2.*s.r+k_p.*(k_p+((-1)+s.K).*(s.K+k_p).*s.r))))).*T.^(-1).*((-1)+coth(k_p));
%

Ik = exp(-s.w0^2.*kSqGrid/8); % PSF in s.K-space

% normalization
F_norm = Ik.^2.*(s.frac.*diff_term_norm+(1-s.frac).*static_term_norm)+s.sigma;

% normalized correlation function
F = (Ik.^2.*(s.frac.*diff_term+(1-s.frac).*static_term))./...
    F_norm;

% the best measure for the error, so far, seems to be to calculate the LS
% of each curve in tau individually, and then sum it. This is instead of
% calculating the norm point-by-point.
if errBool
    err = sum(sqrt(sum((F-ydata).^2,1)),2);
end

if ~errBool % output function
    out = F;
else % output error
    out = err;
end

if isnan(out)
    error(['Function is undefined for params: ',num2str(params),'.'])
end
